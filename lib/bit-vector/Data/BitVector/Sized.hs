{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RoleAnnotations #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UnicodeSyntax #-}

{- |

Copyright   : ¬© 2020 Alex Washburn
License     : BSD-3-Clause
Maintainer  : github@recursion.ninja
Stability   : Stable

Little-endian bit vectors of dependantly-typed length which are isomorphic to a @[Bool]@ with the /least/ significant bit at the head of the list and the /most/ significant bit at the end of the list. Consequently, the endianness of a bit vector affects the semantics of the following typeclasses:

  * Bits
  * FiniteBits
  * Num
-}
module Data.BitVector.Sized (
    -- * Data-type
    BitVector (..),
    KnownNat,

    -- * Construction
    fromBits,
    fromNumber,

    -- * Conversion
    toBits,
    toBytes,
    toWords,
    toNumber,

    -- * Queries
    dimension,

    -- ** Conversions

    -- * Rendering
    renderBin,
    renderDec,
    renderHex,
) where

import Control.DeepSeq
import Data.Bit (Bit (..))
import Data.Bit qualified as VB
import Data.Bits
import Data.Data
import Data.Foldable hiding (toList)
import Data.Foldable qualified as Fold
import Data.Hashable
import Data.Vector.Unboxed qualified as VU
import Data.Vector.Unboxed.Sized (Vector)
import Data.Vector.Unboxed.Sized qualified as VUS
import Data.Word
import GHC.Exts (IsList (..))
import GHC.Generics (Generic)
import GHC.Natural
import GHC.TypeNats
import Unsafe.Coerce (unsafeCoerce)


{- |
A little-endian bit vector of non-negative dimension.
-}
newtype BitVector (w ‚à∑ Nat) = BV (Vector w Bit)


type role BitVector phantom


-- | @since 0.1.0
deriving stock instance Generic (BitVector w)


-- | @since 0.1.0
deriving anyclass instance NFData (BitVector w)


-- | @since 0.1.0
deriving newtype instance Eq (BitVector w)


-- | @since 0.1.0
deriving newtype instance (KnownNat w) ‚áí Bits (BitVector w)


-- | @since 0.1.0
deriving newtype instance (KnownNat w) ‚áí FiniteBits (BitVector w)


-- | @since 0.1.0
deriving newtype instance Ord (BitVector w)


-- | @since 0.1.0
deriving newtype instance (KnownNat w) ‚áí Read (BitVector w)


-- | @since 0.1.0
instance Hashable (BitVector d) where
    hash = hashWithSalt 0


    hashWithSalt salt (BV v) =
        let int2Word ‚à∑ Int ‚Üí Word
            int2Word = unsafeCoerce
            word2Int ‚à∑ Word ‚Üí Int
            word2Int = unsafeCoerce
        in  word2Int . VU.foldr xor (int2Word salt) . VB.cloneToWords $ VUS.fromSized v


-- | @since 0.1.0
instance (KnownNat w) ‚áí Num (BitVector w) where
    {-# INLINE (+) #-}
    (+) = binaryOperationModulo (+)


    {-# INLINE (*) #-}
    (*) = binaryOperationModulo (*)


    {-# INLINE (-) #-}
    (-) x (BV v) =
        let m = naturalBV x

            compute ‚à∑ Proxy w ‚Üí BitVector w
            compute pxy =
                let base ‚à∑ Int
                    base = fromEnum $ natVal pxy

                    modulus ‚à∑ Natural
                    modulus = 1 `shiftL` base

                    performOperation ‚à∑ VU.Vector Bit ‚Üí VU.Vector Bit
                    performOperation w =
                        let n = naturalVU . VB.cloneToWords8 $ w
                            naturalValue ‚à∑ Natural
                            naturalValue = case m `compare` n of
                                LT ‚Üí modulus - (n - m)
                                _ ‚Üí m - n
                        in  VU.take base . VB.castFromWords8 $ natBytes naturalValue
                in  BV $ VUS.withVectorUnsafe performOperation v
        in  VUS.knownLength' v compute


    {-# INLINE abs #-}
    abs = id


    {-# INLINE signum #-}
    signum = const zeroBits


    fromInteger = undefined


    {-# INLINE negate #-}
    negate = id


-- | @since 0.1.0
instance (KnownNat w) ‚áí Show (BitVector w) where
    show bv@(BV v) =
        let render ‚à∑ Proxy w ‚Üí String
            render pxy =
                let n ‚à∑ Natural
                    n = natVal pxy
                    prefix = renderField n
                    format = case n of
                        08 ‚Üí renderHex
                        16 ‚Üí renderHex
                        32 ‚Üí renderHex
                        dim | dim >= 64 ‚Üí renderHex
                        _ ‚Üí renderBin
                in  unwords [prefix, format bv]
        in  VUS.knownLength' v render


{- |
/Time:/ \(\, \mathcal{O} \left( 1 \right) \)

/Since: 0.1.0/

Get the dimension of a bit-vector. Preferable to 'finiteBitSize' as it
returns a type which cannot represent a non-negative value and a bit-vector
must have a non-negative dimension.

==== __Examples__

>>> dimension $ ùô±ùöÖ‚ÇÉ 010
2

>>> dimension $ ùô±ùöÖ‚ÇÑ 0011
4
-}
dimension ‚à∑ BitVector w ‚Üí Word
dimension (BV w) = toEnum . VU.length $ VUS.fromSized w


{- |
/Time:/ \(\, \mathcal{O} \left( n \right) \)

/Since: 0.1.0/

Create a bit-vector of length \( w \) from a /little-endian/ list of "bits."

All 'Enum' values within the input list are treated as @True@ unless the following holds for a value @val@:
>>> toEnum 0 == val

The following properties will hold:

> length . takeWhile not === countLeadingZeros . fromBits
> length . takeWhile not . reverse === countTrailingZeros . fromBits

==== __Examples__

>>> fromBits [True, False, False]
ùô±ùöÖ‚ÇÉ 100
-}
{-# INLINEABLE fromBits #-}
fromBits ‚à∑ ‚àÄ b f w. (Eq b, Foldable f, Enum b, KnownNat w) ‚áí f b ‚Üí BitVector w
fromBits input =
    let pxy ‚à∑ Proxy w
        pxy = Proxy

        base ‚à∑ Int
        base = fromEnum $ natVal pxy

        valZero ‚à∑ b
        valZero = toEnum 0

        toBit ‚à∑ b ‚Üí Bit
        toBit = Bit . (/= valZero)

        align ‚à∑ VU.Vector Bit ‚Üí VU.Vector Bit
        align xs =
            let less = VU.take base xs
                len = VU.length less
                off
                    | base > len = base - len
                    | otherwise = 0
                more = VU.replicate off $ Bit False
            in  less <> more

        valBits ‚à∑ VU.Vector Bit
        valBits = align . VU.fromList . fmap toBit $ Fold.toList input

        valOnes ‚à∑ VUS.Vector w Bit
        valOnes = VUS.replicate' pxy $ Bit True
    in  BV $ VUS.withVectorUnsafe (const valBits) valOnes


fromNumber ‚à∑ ‚àÄ i w. (Integral i, KnownNat w) ‚áí i ‚Üí BitVector w
fromNumber input =
    let pxy ‚à∑ Proxy w
        pxy = Proxy

        base ‚à∑ Int
        base = fromEnum $ natVal pxy

        numBytes ‚à∑ Int
        numBytes = case base `divMod` finiteBitSize (0 ‚à∑ Word) of
            (q, 0) ‚Üí q
            (q, _) ‚Üí q + 1

        modulus ‚à∑ Integer
        modulus = 1 `shiftL` base

        padding ‚à∑ VU.Vector Word ‚Üí VU.Vector Word
        padding vec =
            let len = VU.length vec
                off
                    | numBytes > len = numBytes - len
                    | otherwise = 0
                pad = VU.replicate off 0
            in  vec <> pad

        valInt ‚à∑ Integer
        valInt = toInteger input

        valNat ‚à∑ Natural
        valNat = fromIntegral $ valInt `mod` modulus

        valBytes ‚à∑ VU.Vector Word
        valBytes = natWords valNat

        valBits ‚à∑ VU.Vector Bit
        valBits = VU.take base . VB.castFromWords $ padding valBytes

        valOnes ‚à∑ VUS.Vector w Bit
        valOnes = VUS.replicate' pxy $ Bit True
    in  BV $ VUS.withVectorUnsafe (const valBits) valOnes


{- |
/Time:/ \(\, \mathcal{O} \left( n \right) \)

/Since:/ 0.1.0

Create a /little-endian/ list of bits from a bit vector.

The following will hold:

> length . takeWhile not . toBits === countLeadingZeros
> length . takeWhile not . reverse . toBits === countTrailingZeros

==== __Examples__

>>> toBits [4]11
ùô±ùöÖ‚ÇÑ 1101
-}
{-# INLINEABLE toBits #-}
toBits ‚à∑ ‚àÄ b t w. (Enum b, IsList t, Item t ~ b) ‚áí BitVector w ‚Üí t
toBits (BV v) =
    let convertBit ‚à∑ Bit ‚Üí b
        convertBit (Bit bitIsTrue)
            | bitIsTrue = toEnum 1
            | otherwise = toEnum 0
    in  fromList $ convertBit <$> VUS.toList v


{- |
/Time:/ \(\, \mathcal{O} \left( \frac{w}{64} \right) \)

/Since: 0.1.0/

Unsigned value of a bit-vector.
-}
{-# INLINEABLE toNumber #-}
toNumber ‚à∑ ‚àÄ i w. (Integral i) ‚áí BitVector w ‚Üí i
toNumber (BV v) =
    let width ‚à∑ Int
        width = finiteBitSize (0 ‚à∑ Word)

        addUp ‚à∑ Word ‚Üí (Natural, Natural) ‚Üí (Natural, Natural)
        addUp val (s, b) = (fromIntegral val * b + s, b `shiftL` width)
    in  fromIntegral . fst . VU.foldr addUp (0, 1) $ getWords v


{- |
/Time:/ \(\, \mathcal{O} \left( \frac{w}{8} \right) \)

/Since: 0.1.0/

The bytes of a bit-vector.
-}
toBytes ‚à∑ ‚àÄ t w. (IsList t, Item t ~ Word8) ‚áí BitVector w ‚Üí t
toBytes (BV v) = fromList . VU.toList $ getBytes v


{- |
/Time:/ \(\, \mathcal{O} \left( \frac{w}{64} \right) \)

/Since: 0.1.0/

The words of a bit-vector.
-}
toWords ‚à∑ ‚àÄ t w. (IsList t, Item t ~ Word) ‚áí BitVector w ‚Üí t
toWords (BV v) = fromList . VU.toList $ getWords v


binaryOperationModulo
    ‚à∑ ‚àÄ w
     . (KnownNat w)
    ‚áí (Natural ‚Üí Natural ‚Üí Natural)
    ‚Üí BitVector w
    ‚Üí BitVector w
    ‚Üí BitVector w
binaryOperationModulo op x (BV v) =
    let m = naturalBV x

        compute ‚à∑ Proxy w ‚Üí BitVector w
        compute pxy =
            let base ‚à∑ Int
                base = fromEnum $ natVal pxy

                modulus ‚à∑ Natural
                modulus = 1 `shiftL` base

                performOperation ‚à∑ VU.Vector Bit ‚Üí VU.Vector Bit
                performOperation w =
                    let n = naturalVU . VB.cloneToWords8 $ w
                        naturalValue ‚à∑ Natural
                        naturalValue = (m `op` n) `mod` modulus
                    in  VU.take base . VB.castFromWords8 $ natBytes naturalValue
            in  BV $ VUS.withVectorUnsafe performOperation v
    in  VUS.knownLength' v compute


getBytes ‚à∑ Vector w Bit ‚Üí VU.Vector Word8
getBytes = VB.cloneToWords8 . VUS.fromSized


getWords ‚à∑ Vector w Bit ‚Üí VU.Vector Word
getWords = VB.cloneToWords . VUS.fromSized


natBytes ‚à∑ Natural ‚Üí VU.Vector Word8
natBytes input =
    let mask ‚à∑ Natural
        mask = fromIntegral (maxBound ‚à∑ Word8)

        go ‚à∑ Natural ‚Üí Maybe (Word8, Natural)
        go = \case
            0 ‚Üí Nothing
            n ‚Üí
                let byte = fromIntegral $ mask .&. n
                    next = n `shiftR` 8
                in  Just (byte, next)
    in  VU.unfoldr go input


natWords ‚à∑ Natural ‚Üí VU.Vector Word
natWords input =
    let mask ‚à∑ Natural
        mask = fromIntegral (maxBound ‚à∑ Word)

        size ‚à∑ Int
        size = finiteBitSize (0 ‚à∑ Word)

        go ‚à∑ Natural ‚Üí Maybe (Word, Natural)
        go = \case
            0 ‚Üí Nothing
            n ‚Üí
                let byte = fromIntegral $ mask .&. n
                    next = n `shiftR` size
                in  Just (byte, next)
    in  VU.unfoldr go input


naturalBV ‚à∑ BitVector w ‚Üí Natural
naturalBV (BV v) = naturalVU $ getBytes v


naturalVU ‚à∑ VU.Vector Word8 ‚Üí Natural
naturalVU =
    let addUp ‚à∑ Word8 ‚Üí (Natural, Natural) ‚Üí (Natural, Natural)
        addUp val (s, b) = (fromIntegral val * b + s, b `shiftL` 8)
    in  fst . VU.foldr addUp (0, 1)


renderField ‚à∑ Natural ‚Üí String
renderField dim =
    let makeSubscript ‚à∑ Char ‚Üí Char
        makeSubscript = \case
            '0' ‚Üí '‚ÇÄ'
            '1' ‚Üí '‚ÇÅ'
            '2' ‚Üí '‚ÇÇ'
            '3' ‚Üí '‚ÇÉ'
            '4' ‚Üí '‚ÇÑ'
            '5' ‚Üí '‚ÇÖ'
            '6' ‚Üí '‚ÇÜ'
            '7' ‚Üí '‚Çá'
            '8' ‚Üí '‚Çà'
            '9' ‚Üí '‚Çâ'
            c ‚Üí c
    in  fold ["ùô±ùöÖ", makeSubscript <$> show dim]


renderBin ‚à∑ BitVector w ‚Üí String
renderBin (BV v) =
    let getBit ‚à∑ Bit ‚Üí String ‚Üí String
        getBit (Bit bitIsTrue)
            | bitIsTrue = ('1' :)
            | otherwise = ('0' :)
    in  VUS.foldr getBit mempty v


renderDec ‚à∑ BitVector w ‚Üí String
renderDec = show . naturalBV


renderHex ‚à∑ ‚àÄ w. (KnownNat w) ‚áí BitVector w ‚Üí String
renderHex (BV v) =
    let getNibbles ‚à∑ Word8 ‚Üí String
        getNibbles byte =
            let lo = byte .&. 0x0F
                hi = (byte .&. 0xF0) `shiftR` 4
                go = \case
                    00 ‚Üí '0'
                    01 ‚Üí '1'
                    02 ‚Üí '2'
                    03 ‚Üí '3'
                    04 ‚Üí '4'
                    05 ‚Üí '5'
                    06 ‚Üí '6'
                    07 ‚Üí '7'
                    08 ‚Üí '8'
                    09 ‚Üí '9'
                    10 ‚Üí 'A'
                    11 ‚Üí 'B'
                    12 ‚Üí 'C'
                    13 ‚Üí 'D'
                    14 ‚Üí 'E'
                    _ ‚Üí 'F'
            in  [go lo, go hi]

        render ‚à∑ Proxy w ‚Üí String
        render pxy =
            let n ‚à∑ Natural
                n = natVal pxy
                mask
                    | pred n `mod` 8 < 4 = snip
                    | otherwise = id

                snip ‚à∑ String ‚Üí String
                snip = \case
                    [] ‚Üí []
                    [x] ‚Üí [x]
                    [x, _] ‚Üí [x]
                    x : y : zs ‚Üí x : snip (y : zs)
            in  mask . VU.foldMap getNibbles $ getBytes v
    in  VUS.knownLength' v render
